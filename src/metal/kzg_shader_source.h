/*
 * Auto-generated from kzg_kernels.metal - DO NOT EDIT
 *
 * This file contains the Metal shader source embedded as a C string literal.
 * Regenerate with: python3 generate_shader_source.py
 */

#pragma once

/* Disable overlength-strings warning for this file - the shader is necessarily long */
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverlength-strings"
#endif

static const char *METAL_SHADER_SOURCE =
    "/*\n"
    " * Copyright 2024 Benjamin Edgington\n"
    " *\n"
    " * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
    " * you may not use this file except in compliance with the License.\n"
    " * You may obtain a copy of the License at\n"
    " *\n"
    " *     http://www.apache.org/licenses/LICENSE-2.0\n"
    " *\n"
    " * Unless required by applicable law or agreed to in writing, software\n"
    " * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
    " * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
    " * See the License for the specific language governing permissions and\n"
    " * limitations under the License.\n"
    " */\n"
    "\n"
    "#include <metal_stdlib>\n"
    "using namespace metal;\n"
    "\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "// BLS12-381 Field Constants\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "\n"
    "/*\n"
    " * BLS12-381 scalar field modulus (r):\n"
    " * r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\n"
    " *\n"
    " * In 4x64-bit limbs (little-endian):\n"
    " * r[0] = 0xffffffff00000001\n"
    " * r[1] = 0x53bda402fffe5bfe\n"
    " * r[2] = 0x3339d80809a1d805\n"
    " * r[3] = 0x73eda753299d7d48\n"
    " */\n"
    "\n"
    "// BLS12-381 scalar field modulus in 4x64-bit limbs\n"
    "constant ulong4 MODULUS = ulong4(\n"
    "    0xffffffff00000001UL,\n"
    "    0x53bda402fffe5bfeUL,\n"
    "    0x3339d80809a1d805UL,\n"
    "    0x73eda753299d7d48UL\n"
    ");\n"
    "\n"
    "// Montgomery R^2 mod p for converting to Montgomery form\n"
    "// R = 2^256, R^2 mod r\n"
    "constant ulong4 R2 = ulong4(\n"
    "    0xc999e990f3f29c6dUL,\n"
    "    0x2b6cedcb87925c23UL,\n"
    "    0x05d314967254398fUL,\n"
    "    0x0748d9d99f59ff11UL\n"
    ");\n"
    "\n"
    "// Montgomery constant: -r^(-1) mod 2^64\n"
    "constant ulong INV = 0xfffffffeffffffffUL;\n"
    "\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "// Field Element Type (256-bit in Montgomery form)\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "\n"
    "// A field element is represented as 4x64-bit limbs in little-endian order\n"
    "// We use an array of 4 ulongs\n"
    "struct Fr {\n"
    "    ulong l[4];\n"
    "};\n"
    "\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "// Low-level Arithmetic Helpers\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "\n"
    "// Add two 64-bit values with carry-in, return result and carry-out\n"
    "inline ulong adc(ulong a, ulong b, thread ulong &carry) {\n"
    "    // Use 128-bit arithmetic via __uint128_t equivalent\n"
    "    ulong sum = a + b + carry;\n"
    "    carry = ((sum < a) || (carry && sum == a)) ? 1UL : 0UL;\n"
    "    return sum;\n"
    "}\n"
    "\n"
    "// Multiply two 64-bit values, return low 64 bits, store high 64 bits in hi\n"
    "inline ulong mul64(ulong a, ulong b, thread ulong &hi) {\n"
    "    // Metal doesn't have native 128-bit arithmetic, so we use 32-bit parts\n"
    "    ulong a_lo = a & 0xFFFFFFFFUL;\n"
    "    ulong a_hi = a >> 32;\n"
    "    ulong b_lo = b & 0xFFFFFFFFUL;\n"
    "    ulong b_hi = b >> 32;\n"
    "\n"
    "    ulong p0 = a_lo * b_lo;\n"
    "    ulong p1 = a_lo * b_hi;\n"
    "    ulong p2 = a_hi * b_lo;\n"
    "    ulong p3 = a_hi * b_hi;\n"
    "\n"
    "    ulong mid = p1 + p2;\n"
    "    ulong mid_carry = (mid < p1) ? 1UL : 0UL;\n"
    "\n"
    "    ulong lo = p0 + (mid << 32);\n"
    "    ulong lo_carry = (lo < p0) ? 1UL : 0UL;\n"
    "\n"
    "    hi = p3 + (mid >> 32) + (mid_carry << 32) + lo_carry;\n"
    "\n"
    "    return lo;\n"
    "}\n"
    "\n"
    "// Multiply-add: result = a * b + c, return low 64 bits, add high to hi\n"
    "inline ulong mac(ulong a, ulong b, ulong c, thread ulong &hi) {\n"
    "    ulong prod_hi;\n"
    "    ulong prod_lo = mul64(a, b, prod_hi);\n"
    "\n"
    "    ulong sum = prod_lo + c;\n"
    "    ulong sum_carry = (sum < prod_lo) ? 1UL : 0UL;\n"
    "\n"
    "    hi += prod_hi + sum_carry;\n"
    "    return sum;\n"
    "}\n"
    "\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "// Field Arithmetic Operations\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "\n"
    "// Subtract modulus if result >= modulus (conditional subtraction)\n"
    "inline void fr_reduce(thread Fr &a) {\n"
    "    // Check if a >= MODULUS\n"
    "    bool ge = false;\n"
    "    if (a.l[3] > MODULUS.w) ge = true;\n"
    "    else if (a.l[3] == MODULUS.w) {\n"
    "        if (a.l[2] > MODULUS.z) ge = true;\n"
    "        else if (a.l[2] == MODULUS.z) {\n"
    "            if (a.l[1] > MODULUS.y) ge = true;\n"
    "            else if (a.l[1] == MODULUS.y) {\n"
    "                if (a.l[0] >= MODULUS.x) ge = true;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    if (ge) {\n"
    "        ulong borrow = 0;\n"
    "        ulong diff;\n"
    "\n"
    "        diff = a.l[0] - MODULUS.x - borrow;\n"
    "        borrow = (a.l[0] < MODULUS.x + borrow) ? 1UL : 0UL;\n"
    "        a.l[0] = diff;\n"
    "\n"
    "        diff = a.l[1] - MODULUS.y - borrow;\n"
    "        borrow = (a.l[1] < MODULUS.y + borrow) ? 1UL : 0UL;\n"
    "        a.l[1] = diff;\n"
    "\n"
    "        diff = a.l[2] - MODULUS.z - borrow;\n"
    "        borrow = (a.l[2] < MODULUS.z + borrow) ? 1UL : 0UL;\n"
    "        a.l[2] = diff;\n"
    "\n"
    "        a.l[3] = a.l[3] - MODULUS.w - borrow;\n"
    "    }\n"
    "}\n"
    "\n"
    "// Field addition: out = a + b mod p\n"
    "inline Fr fr_add(Fr a, Fr b) {\n"
    "    Fr result;\n"
    "    ulong carry = 0;\n"
    "\n"
    "    result.l[0] = adc(a.l[0], b.l[0], carry);\n"
    "    result.l[1] = adc(a.l[1], b.l[1], carry);\n"
    "    result.l[2] = adc(a.l[2], b.l[2], carry);\n"
    "    result.l[3] = adc(a.l[3], b.l[3], carry);\n"
    "\n"
    "    // Reduce if necessary\n"
    "    fr_reduce(result);\n"
    "\n"
    "    return result;\n"
    "}\n"
    "\n"
    "// Field subtraction: out = a - b mod p\n"
    "inline Fr fr_sub(Fr a, Fr b) {\n"
    "    Fr result;\n"
    "    ulong borrow = 0;\n"
    "\n"
    "    // Compute a - b\n"
    "    ulong diff0 = a.l[0] - b.l[0];\n"
    "    borrow = (a.l[0] < b.l[0]) ? 1UL : 0UL;\n"
    "\n"
    "    ulong diff1 = a.l[1] - b.l[1] - borrow;\n"
    "    borrow = (a.l[1] < b.l[1] + borrow) ? 1UL : 0UL;\n"
    "\n"
    "    ulong diff2 = a.l[2] - b.l[2] - borrow;\n"
    "    borrow = (a.l[2] < b.l[2] + borrow) ? 1UL : 0UL;\n"
    "\n"
    "    ulong diff3 = a.l[3] - b.l[3] - borrow;\n"
    "    borrow = (a.l[3] < b.l[3] + borrow) ? 1UL : 0UL;\n"
    "\n"
    "    result.l[0] = diff0;\n"
    "    result.l[1] = diff1;\n"
    "    result.l[2] = diff2;\n"
    "    result.l[3] = diff3;\n"
    "\n"
    "    // If borrow occurred, add modulus back\n"
    "    if (borrow) {\n"
    "        ulong carry = 0;\n"
    "        result.l[0] = adc(result.l[0], MODULUS.x, carry);\n"
    "        result.l[1] = adc(result.l[1], MODULUS.y, carry);\n"
    "        result.l[2] = adc(result.l[2], MODULUS.z, carry);\n"
    "        result.l[3] = adc(result.l[3], MODULUS.w, carry);\n"
    "    }\n"
    "\n"
    "    return result;\n"
    "}\n"
    "\n"
    "// Montgomery multiplication: out = a * b * R^(-1) mod p\n"
    "// Using CIOS (Coarsely Integrated Operand Scanning) method\n"
    "inline Fr fr_mul(Fr a, Fr b) {\n"
    "    // Temporary storage for intermediate results (8 limbs)\n"
    "    ulong t[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n"
    "\n"
    "    // Multiply and accumulate\n"
    "    for (int i = 0; i < 4; i++) {\n"
    "        ulong carry = 0;\n"
    "\n"
    "        // Multiply a * b[i] and add to t\n"
    "        for (int j = 0; j < 4; j++) {\n"
    "            ulong hi = 0;\n"
    "            ulong lo = mac(a.l[j], b.l[i], t[i + j], hi);\n"
    "            lo += carry;\n"
    "            if (lo < carry) hi++;\n"
    "            t[i + j] = lo;\n"
    "            carry = hi;\n"
    "        }\n"
    "        t[i + 4] += carry;\n"
    "\n"
    "        // Montgomery reduction step\n"
    "        ulong m = t[i] * INV;\n"
    "        carry = 0;\n"
    "\n"
    "        // Add m * MODULUS to t, shifted by i limbs\n"
    "        ulong hi = 0;\n"
    "        ulong lo = mac(m, MODULUS.x, t[i], hi);\n"
    "        carry = hi;\n"
    "\n"
    "        hi = 0;\n"
    "        lo = mac(m, MODULUS.y, t[i + 1], hi);\n"
    "        lo += carry;\n"
    "        if (lo < carry) hi++;\n"
    "        t[i + 1] = lo;\n"
    "        carry = hi;\n"
    "\n"
    "        hi = 0;\n"
    "        lo = mac(m, MODULUS.z, t[i + 2], hi);\n"
    "        lo += carry;\n"
    "        if (lo < carry) hi++;\n"
    "        t[i + 2] = lo;\n"
    "        carry = hi;\n"
    "\n"
    "        hi = 0;\n"
    "        lo = mac(m, MODULUS.w, t[i + 3], hi);\n"
    "        lo += carry;\n"
    "        if (lo < carry) hi++;\n"
    "        t[i + 3] = lo;\n"
    "        carry = hi;\n"
    "\n"
    "        t[i + 4] += carry;\n"
    "        if (t[i + 4] < carry && i + 5 < 8) {\n"
    "            t[i + 5]++;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    // Result is in t[4..7]\n"
    "    Fr result;\n"
    "    result.l[0] = t[4];\n"
    "    result.l[1] = t[5];\n"
    "    result.l[2] = t[6];\n"
    "    result.l[3] = t[7];\n"
    "\n"
    "    // Final reduction\n"
    "    fr_reduce(result);\n"
    "\n"
    "    return result;\n"
    "}\n"
    "\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "// FFT Kernels\n"
    "//////////////////////////////////////////////////////////////////////////////////////////////"
    "//////\n"
    "\n"
    "/*\n"
    " * Cooley-Tukey FFT butterfly operation.\n"
    " *\n"
    " * For each pair (a, b) at distance `half_n` apart:\n"
    " *   a' = a + w * b\n"
    " *   b' = a - w * b\n"
    " *\n"
    " * where w is the twiddle factor (root of unity).\n"
    " */\n"
    "kernel void fft_butterfly(\n"
    "    device Fr *data [[buffer(0)]],\n"
    "    constant Fr *roots [[buffer(1)]],\n"
    "    constant uint &n [[buffer(2)]],\n"
    "    constant uint &half_n [[buffer(3)]],\n"
    "    constant uint &roots_stride [[buffer(4)]],\n"
    "    uint gid [[thread_position_in_grid]]\n"
    ") {\n"
    "    // Each thread handles one butterfly\n"
    "    uint block_size = half_n * 2;\n"
    "    uint block_idx = gid / half_n;\n"
    "    uint idx_in_block = gid % half_n;\n"
    "\n"
    "    if (block_idx * block_size + idx_in_block + half_n >= n) return;\n"
    "\n"
    "    uint i = block_idx * block_size + idx_in_block;\n"
    "    uint j = i + half_n;\n"
    "\n"
    "    // Get twiddle factor\n"
    "    uint root_idx = idx_in_block * roots_stride;\n"
    "    Fr w = roots[root_idx];\n"
    "\n"
    "    // Load values\n"
    "    Fr a = data[i];\n"
    "    Fr b = data[j];\n"
    "\n"
    "    // Compute w * b\n"
    "    Fr wb = fr_mul(w, b);\n"
    "\n"
    "    // Compute butterfly\n"
    "    data[i] = fr_add(a, wb);\n"
    "    data[j] = fr_sub(a, wb);\n"
    "}\n"
    "\n"
    "/*\n"
    " * Bit-reversal permutation kernel.\n"
    " * Swaps elements at positions i and bit_reverse(i).\n"
    " */\n"
    "kernel void bit_reversal(\n"
    "    device Fr *data [[buffer(0)]],\n"
    "    constant uint &n [[buffer(1)]],\n"
    "    constant uint &log_n [[buffer(2)]],\n"
    "    uint gid [[thread_position_in_grid]]\n"
    ") {\n"
    "    if (gid >= n) return;\n"
    "\n"
    "    // Compute bit-reversed index\n"
    "    uint rev = 0;\n"
    "    uint val = gid;\n"
    "    for (uint i = 0; i < log_n; i++) {\n"
    "        rev = (rev << 1) | (val & 1);\n"
    "        val >>= 1;\n"
    "    }\n"
    "\n"
    "    // Only swap if gid < rev to avoid double-swapping\n"
    "    if (gid < rev && rev < n) {\n"
    "        Fr temp = data[gid];\n"
    "        data[gid] = data[rev];\n"
    "        data[rev] = temp;\n"
    "    }\n"
    "}\n"
    "\n"
    "/*\n"
    " * Scale all elements by a constant factor (for inverse FFT).\n"
    " */\n"
    "kernel void scale_elements(\n"
    "    device Fr *data [[buffer(0)]],\n"
    "    constant Fr &scale [[buffer(1)]],\n"
    "    constant uint &n [[buffer(2)]],\n"
    "    uint gid [[thread_position_in_grid]]\n"
    ") {\n"
    "    if (gid >= n) return;\n"
    "    data[gid] = fr_mul(data[gid], scale);\n"
    "}\n"
    "\n"
    "/*\n"
    " * Combined FFT butterfly for multiple stages.\n"
    " * More efficient by reducing kernel launch overhead.\n"
    " */\n"
    "kernel void fft_radix2_stage(\n"
    "    device Fr *data [[buffer(0)]],\n"
    "    constant Fr *roots [[buffer(1)]],\n"
    "    constant uint &n [[buffer(2)]],\n"
    "    constant uint &stage [[buffer(3)]],\n"
    "    constant uint &roots_stride_base [[buffer(4)]],\n"
    "    uint gid [[thread_position_in_grid]]\n"
    ") {\n"
    "    uint half_n = 1u << stage;\n"
    "    uint block_size = half_n * 2;\n"
    "    uint num_butterflies = n / 2;\n"
    "\n"
    "    if (gid >= num_butterflies) return;\n"
    "\n"
    "    uint block_idx = gid / half_n;\n"
    "    uint idx_in_block = gid % half_n;\n"
    "\n"
    "    uint i = block_idx * block_size + idx_in_block;\n"
    "    uint j = i + half_n;\n"
    "\n"
    "    // Calculate roots stride for this stage\n"
    "    uint roots_stride = roots_stride_base >> stage;\n"
    "    uint root_idx = idx_in_block * roots_stride;\n"
    "\n"
    "    Fr w = roots[root_idx];\n"
    "    Fr a = data[i];\n"
    "    Fr b = data[j];\n"
    "\n"
    "    Fr wb = fr_mul(w, b);\n"
    "\n"
    "    data[i] = fr_add(a, wb);\n"
    "    data[j] = fr_sub(a, wb);\n"
    "}\n"
    "\n"
    "/*\n"
    " * Copy kernel for data transfer.\n"
    " */\n"
    "kernel void copy_elements(\n"
    "    device Fr *dst [[buffer(0)]],\n"
    "    constant Fr *src [[buffer(1)]],\n"
    "    constant uint &n [[buffer(2)]],\n"
    "    uint gid [[thread_position_in_grid]]\n"
    ") {\n"
    "    if (gid >= n) return;\n"
    "    dst[gid] = src[gid];\n"
    "}\n"
    "";

#ifdef __clang__
#pragma clang diagnostic pop
#endif
